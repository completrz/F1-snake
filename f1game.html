<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>F1 Snake â€” Tail & Obstacles</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    html,body { height:100%; margin:0; background:#111; overflow:hidden; font-family:sans-serif; }
    #ui {
      position: absolute; top: 12px; left: 12px; color: #fff; z-index: 10;
      background: rgba(0,0,0,0.25); padding: 8px 10px; border-radius: 8px;
    }
  </style>
</head>
<body>
  <div id="ui">Score: <span id="score">0</span></div>

  <script src="https://unpkg.com/three@0.154.0/build/three.min.js"></script>
  <script>
  // --- CONFIG ---
  const ARENA_RADIUS = 120;
  const SEGMENT_DISTANCE = 6;
  const SPEED = 1.5;
  const OBSTACLE_COUNT = 10;

  // --- SCENE SETUP ---
  const scene = new THREE.Scene();
  scene.fog = new THREE.FogExp2(0x111111, 0.0025);
  const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.5, 1000);
  const renderer = new THREE.WebGLRenderer({antialias:true});
  renderer.setSize(innerWidth, innerHeight);
  document.body.appendChild(renderer.domElement);

  const light = new THREE.HemisphereLight(0xffffff, 0x444444, 1);
  scene.add(light);

  // ground
  const ground = new THREE.Mesh(
    new THREE.CircleGeometry(ARENA_RADIUS, 64),
    new THREE.MeshStandardMaterial({color:0x0d3b66})
  );
  ground.rotation.x = -Math.PI/2;
  scene.add(ground);

  // --- CREATE CAR MESH ---
  function makeCar(color=0xff2d55) {
    const group = new THREE.Group();
    const body = new THREE.Mesh(
      new THREE.BoxGeometry(3.4, 1.2, 7.6),
      new THREE.MeshStandardMaterial({color})
    );
    body.position.y = 1;
    group.add(body);
    const nose = new THREE.Mesh(
      new THREE.BoxGeometry(2.6, 0.8, 2.6),
      new THREE.MeshStandardMaterial({color:color+0x222222})
    );
    nose.position.set(0, 1.08, 3.25);
    group.add(nose);
    return group;
  }

  // --- PLAYER & FOLLOWERS ---
  const cars = [];
  cars.push(makeCar());
  scene.add(cars[0]);
  cars[0].position.set(0,1,0);

  // --- PICKUPS ---
  const pickups = [];
  function spawnPickup() {
    const r = THREE.MathUtils.randFloat(10, ARENA_RADIUS-10);
    const a = THREE.MathUtils.randFloat(0, Math.PI*2);
    const x = Math.cos(a)*r, z = Math.sin(a)*r;
    const mesh = new THREE.Mesh(
      new THREE.ConeGeometry(1.2, 2.2, 10),
      new THREE.MeshStandardMaterial({color:0x00ffae})
    );
    mesh.position.set(x,1.1,z);
    scene.add(mesh);
    pickups.push(mesh);
  }
  for(let i=0;i<6;i++) spawnPickup();

  // --- OBSTACLES ---
  const obstacles = [];
  function spawnObstacles() {
    for(let i=0;i<OBSTACLE_COUNT;i++){
      const r = THREE.MathUtils.randFloat(15, ARENA_RADIUS-15);
      const a = THREE.MathUtils.randFloat(0, Math.PI*2);
      const x = Math.cos(a)*r, z = Math.sin(a)*r;
      const mesh = new THREE.Mesh(
        new THREE.BoxGeometry(6, 6, 6),
        new THREE.MeshStandardMaterial({color:0xaa0000})
      );
      mesh.position.set(x,3,z);
      scene.add(mesh);
      obstacles.push(mesh);
    }
  }
  spawnObstacles();

  // --- CONTROLS ---
  const keys = {};
  onkeydown = e => keys[e.key.toLowerCase()] = true;
  onkeyup = e => keys[e.key.toLowerCase()] = false;

  let score = 0;
  const scoreEl = document.getElementById('score');
  let alive = true;

  // --- GAME LOOP ---
  function animate(){
    requestAnimationFrame(animate);
    if(!alive){
      renderer.render(scene, camera);
      return;
    }

    const player = cars[0];
    if(keys['a']||keys['arrowleft']) player.rotation.y += 0.05;
    if(keys['d']||keys['arrowright']) player.rotation.y -= 0.05;

    const forward = new THREE.Vector3(0,0,1).applyQuaternion(player.quaternion);
    player.position.add(forward.multiplyScalar(SPEED));

    // followers follow leader
    for(let i=1;i<cars.length;i++){
      const leader = cars[i-1];
      const follower = cars[i];
      const dir = new THREE.Vector3().subVectors(leader.position, follower.position);
      const dist = dir.length();
      if(dist > SEGMENT_DISTANCE){
        dir.normalize();
        follower.position.add(dir.multiplyScalar((dist - SEGMENT_DISTANCE)*0.5));
        follower.lookAt(leader.position);
      }
    }

    // pickups collision
    for(let i=pickups.length-1;i>=0;i--){
      if(pickups[i].position.distanceTo(player.position) < 3){
        scene.remove(pickups[i]);
        pickups.splice(i,1);
        score++;
        scoreEl.textContent = score;
        // add new car
        const last = cars[cars.length-1];
        const newCar = makeCar(0xff8a00 + score*5);
        newCar.position.copy(last.position.clone().add(new THREE.Vector3(0,0,-SEGMENT_DISTANCE)));
        scene.add(newCar);
        cars.push(newCar);
        spawnPickup();
      }
    }

    // obstacle collision
    for(const obs of obstacles){
      if(obs.position.distanceTo(player.position) < 4.5){
        scoreEl.textContent = `Crashed into obstacle! Final Score: ${score}`;
        alive = false;
      }
    }

    // boundary check
    if(player.position.length() > ARENA_RADIUS){
      scoreEl.textContent = `Hit the wall! Final Score: ${score}`;
      alive = false;
    }

    // camera follow
    const camOffset = new THREE.Vector3(0,15,-30).applyQuaternion(player.quaternion);
    camera.position.copy(player.position.clone().add(camOffset));
    camera.lookAt(player.position);

    renderer.render(scene, camera);
  }
  animate();

  onresize = () => {
    camera.aspect = innerWidth/innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
  };
  </script>
</body>
</html>
